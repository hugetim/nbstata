# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/03_helpers.ipynb.

# %% auto 0
__all__ = ['parse_sreturn', 'pre', 'kwargs', 'local_def_in', 'SelectVar', 'IndexVar', 'diverted_stata_output',
           'diverted_stata_output_quicker', 'local_names', 'get_local_dict', 'run_as_program_w_locals', 'run_noecho',
           'run_simple', 'dispatch_run', 'get_inspect']

# %% ../nbs/03_helpers.ipynb 3
from .utils import DivertedPrints, break_out_prog_blocks
from .stata import run_direct, run_as_program, get_local, run_prog_noecho, run_non_prog_noecho
from textwrap import dedent
import functools
import re

# %% ../nbs/03_helpers.ipynb 6
class SelectVar():
    """Class for generating Stata select_var for getAsDict"""
    varname = None
    
    def __init__(self, stata_if_code):
        condition = stata_if_code.replace('if ', '', 1).strip()
        if condition:
            cmd = dedent(f"""\
                tempvar __selectionVar
                generate `__selectionVar' = cond({condition},1,0)""")
            run_direct(cmd, quietly=True)      
            self.varname = get_local("__selectionVar")  

    def clear(self):
        """Remove temporary select_var from Stata dataset"""
        import sfi
        if self.varname:
            sfi.Data.dropVar(self.varname)
            sfi.Macro.setLocal("__selectionVar", "")
            
    def __enter__(self):
        return self.varname
    
    def __exit__(self, exc_type, exc_value, exc_tb):
        self.clear()

# %% ../nbs/03_helpers.ipynb 10
class IndexVar:
    def __enter__(self):
        run_direct("""\
            tempvar indexvar
            generate `indexvar' = _n""", quietly=True)
        self.idx_var = get_local('indexvar')
        return self.idx_var
    
    def __exit__(self, exc_type, exc_value, exc_tb):
        import sfi
        sfi.Data.dropVar(self.idx_var)
        sfi.Macro.setLocal('indexvar', "")

# %% ../nbs/03_helpers.ipynb 16
def diverted_stata_output(std_code, runner=None):
    if runner is None:
        runner = functools.partial(run_direct, quietly=False, inline=True, echo=False)
    with DivertedPrints() as diverted:
        run_as_program("return add\ncapture log off", prog_def_option_code="rclass")
        try:
            runner(std_code)
        finally:
            run_as_program("return add\ncapture log on", prog_def_option_code="rclass")
        out = diverted.getvalue()
    return out

# %% ../nbs/03_helpers.ipynb 22
def diverted_stata_output_quicker(std_non_prog_code):
    with DivertedPrints() as diverted:
        code = f"return add\ncapture log off\n{std_non_prog_code}\ncapture log on"""
        try:
            run_as_program(code, prog_def_option_code="rclass")
        except SystemError as e:
            run_as_rclass_prog("return add\ncapture log on")
            raise(e)
        out = diverted.getvalue()
    return out

# %% ../nbs/03_helpers.ipynb 28
def local_names():
    out = diverted_stata_output("""mata : invtokens(st_dir("local", "macro", "*")')""")
    return out.split()

# %% ../nbs/03_helpers.ipynb 30
def get_local_dict(_local_names=None):
    if _local_names is None:
        _local_names = local_names()
    return {n: get_local(n) for n in _local_names}

# %% ../nbs/03_helpers.ipynb 32
def _locals_code_from_dict(preexisting_local_dict):
    local_defs = (f"""local {name} `"{preexisting_local_dict[name]}"'"""
                  for name in preexisting_local_dict)
    return "\n".join(local_defs)

# %% ../nbs/03_helpers.ipynb 38
def _run_as_program_w_locals_sreturned(std_code):
    sreturn_code = dedent("""\
        
        mata : st_local("temp_nbstata_all_locals", invtokens(st_dir("local", "macro", "*")'))
        foreach lname in `temp_nbstata_all_locals' {
            sreturn local `lname' "``lname''"
        }
        """)
    store_new_locals_code = ("sreturn clear\n" 
                             + std_code
                             + sreturn_code)                          
    run_as_program(store_new_locals_code, "sclass")

# %% ../nbs/03_helpers.ipynb 41
parse_sreturn = re.compile(
    r'^\s*?(?:\ss\((?P<name>\w+)\) : \"(?P<value>.+)\"\s)', flags=re.MULTILINE
).findall

# %% ../nbs/03_helpers.ipynb 43
def _local_dict_from_sreturn(sreturn_output):
    matches = parse_sreturn(sreturn_output)
    return {m[0]: m[1] for m in matches}

# %% ../nbs/03_helpers.ipynb 46
def _after_local_dict():
    sreturn_output = diverted_stata_output_quicker("sreturn list")
    return _local_dict_from_sreturn(sreturn_output)

# %% ../nbs/03_helpers.ipynb 47
def _restore_locals_and_clear_sreturn():
    # run non-prog to avoid clearing locals
    after_local_dict = _after_local_dict()
    after_locals_code = _locals_code_from_dict(after_local_dict)
    if after_local_dict:
        after_locals_code += "\n" + "sreturn clear"
    run_direct(after_locals_code, quietly=True)

# %% ../nbs/03_helpers.ipynb 48
pre = (
    r'(cap(t|tu|tur|ture)?'
    r'|qui(e|et|etl|etly)?'
    r'|n(o|oi|ois|oisi|oisil|oisily)?)')
kwargs = {'flags': re.MULTILINE}
local_def_in = re.compile(
    r"(^({0} )*(loc(a|al)?|tempname|tempvar|tempfile|gettoken|token(i|iz|ize)?)\s)|st_local\(".format(pre),
    **kwargs,
).search

# %% ../nbs/03_helpers.ipynb 50
def run_as_program_w_locals(std_code, local_dict=None):
    if local_dict is None:
        local_dict = get_local_dict()
    locals_code = _locals_code_from_dict(local_dict)
    if not local_def_in(std_code):
        run_as_program(f"""{locals_code}\n{std_code}""")
    else:
        _run_as_program_w_locals_sreturned(f"""{locals_code}\n{std_code}""")
        _restore_locals_and_clear_sreturn()

# %% ../nbs/03_helpers.ipynb 54
def run_noecho(code, sc_delimiter=False, run_as_prog=run_as_program_w_locals):
    """After `break_out_prog_blocks`, run each prog and non-prog block noecho"""
    for block in break_out_prog_blocks(code, sc_delimiter):
        if block['is_prog']:
            run_prog_noecho(block['std_code'])
        else:
            run_non_prog_noecho(block['std_code'], run_as_prog=run_as_prog)

# %% ../nbs/03_helpers.ipynb 58
def run_simple(code, quietly=False, echo=False, sc_delimiter=False):
    if sc_delimiter:
        code = "#delimit;\n" + code
    run_direct(code, quietly=quietly, inline=not quietly, echo=echo)

# %% ../nbs/03_helpers.ipynb 60
def dispatch_run(code, quietly=False, echo=False, sc_delimiter=False, noecho=False, run_as_prog=run_as_program_w_locals):
    if noecho and not quietly:
        run_noecho(code, sc_delimiter, run_as_prog=run_as_prog)
    else:
        run_simple(code, quietly, echo, sc_delimiter)   

# %% ../nbs/03_helpers.ipynb 64
def get_inspect(code="", cursor_pos=0, detail_level=0, omit_sections=()):
    runner = functools.partial(run_as_program, prog_def_option_code="rclass")
    inspect_code = """\
        return list
        ereturn list
        return add
        display "*** Last updated `c(current_time)' `c(current_date)' ***"
        describe, fullnames
        """
    raw_output = diverted_stata_output(inspect_code, runner=runner)
    desc_start = raw_output.find('*** Last updated ')
    return raw_output[desc_start:] + raw_output[:desc_start]
