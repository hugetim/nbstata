# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/05_completions.ipynb.

# %% auto 0
__all__ = ['relevant_suggestion_keys', 'CompletionsManager', 'Env']

# %% ../nbs/05_completions.ipynb 4
from .helpers import run_noecho
from .stata_session import StataSession
from fastcore.basics import patch_to
from enum import IntEnum
import os
import re
import platform

# %% ../nbs/05_completions.ipynb 5
class CompletionsManager():
    def __init__(self, stata_session: StataSession):
        self.stata_session = stata_session

        # Path completion
        self.path_search = re.compile(
            r'^(?P<fluff>.*")(?P<path>[^"]*)\Z').search

#         # Magic completion
#         self.magic_completion = re.compile(
#             r'\A%(?P<magic>\S*)\Z', flags=re.DOTALL + re.MULTILINE).match

#         self.set_magic_completion = re.compile(
#             r'\A%set (?P<setting>\S*)\Z', flags=re.DOTALL + re.MULTILINE).match

#         self.matainline = re.compile(r"^m(ata)?\b").search

#         self.matacontext = re.compile(
#             r'(^|\s+)(?P<st>_?st_)'
#             r'(?P<context>\S+?)\('
#             r'(?P<quote>[^\)]*?")'
#             r'(?P<pre>[^\)]*?)\Z', flags=re.MULTILINE + re.DOTALL).search

        # Macth context; this is used to determine if the line starts
        # with matrix or scalar. It also matches constructs like
        #
        #     (`=)?scalar(

        pre = (
            r'(cap(t|tu|tur|ture)?'
            r'|qui(e|et|etl|etly)?'
            r'|n(o|oi|ois|oisi|oisil|oisily)?)')
        kwargs = {'flags': re.MULTILINE}
        self.context = {
            'function':
                re.compile(
                    r"(\s+|(?P<equals>\=))(?P<context>\S+?)"
                    r"\([^\)\s]*?\Z", **kwargs).search,
            'lfunction':
                re.compile(
                    r"\s(?P<fluff>.*?)`\=(?P<context>\S+?)"
                    r"\([^\)\s]*?\Z", **kwargs).search,
            'line':
                re.compile(
                    r"^\s*({0}\s+)*(?P<context>\S+)".format(pre),
                    **kwargs).search,
            'delimit_line':
                re.compile(
                    r"\A\s*({0}\s+)*(?P<context>\S+)".format(pre),
                    **kwargs).search}

# %% ../nbs/05_completions.ipynb 7
@patch_to(CompletionsManager)
def get_file_paths(self, chunk):
    """Get file paths based on chunk
    Args:
        chunk (str): chunk of text after last space. Doesn't include string
            punctuation characters
    Returns:
        (List[str]): folders and files at that location
    """
    from sfi import SFIToolkit
    # If local exists, return empty list
    if re.search(r'[`\']', chunk):
        return []

    # Define directory separator
    dir_sep = '/'
    if platform.system() == 'Windows':
        if '/' not in chunk:
            dir_sep = '\\'

    # Get directory without ending file, and without / or \
    if any(x in chunk for x in ['/', '\\']):
        ind = max(chunk.rfind('/'), chunk.rfind('\\'))
        user_folder = chunk[:ind + 1]
        user_starts = chunk[ind + 1:]

        # Replace multiple consecutive / with a single /
        user_folder = re.sub(r'/+', '/', user_folder)
        user_folder = re.sub(r'\\+', r'\\', user_folder)

    else:
        user_folder = ''
        user_starts = chunk

    # Replace globals with their values
    globals_re = r'\$\{?((?![0-9_])\w{1,32})\}?'
    try:
        folder = re.sub(
            globals_re, lambda x: self.globals[x.group(1)], user_folder)
    except KeyError:
        # If the global doesn't exist in self.globals (aka it hasn't been
        # defined in the Stata environment yet), then there are no paths to
        # check
        return []

    # Use Stata's relative path
    abspath = re.search(r'^([/~]|[a-zA-Z]:)', folder)
    if not abspath:
        folder = SFIToolkit.getWorkingDir() + '/' + folder

    try:
        top_dir, dirs, files = next(os.walk(os.path.expanduser(folder)))
        results = [x + dir_sep for x in dirs] + files
        results = [
            user_folder + x for x in results if not x.startswith('.')
            and re.match(re.escape(user_starts), x, re.I)]

    except StopIteration:
        results = []

    return sorted(results)

# %% ../nbs/05_completions.ipynb 10
class Env(IntEnum):
    GENERAL = 0    # varlist and/or file path
    LOCAL = 1      # `x* completed with `x*'
    GLOBAL = 2     # $x* completed with $x*
    GLOBAL_R = 3   # ${x* completed with ${x*}
    SCALAR = 4     # scalar .* x* completed with x*
    SCALAR_R = 5   # scalar(x* completed with scalar(x*)
    MATRIX = 6     # matrix .* x* completed with x*
    SCALAR_VAR = 7 # scalars and varlist, scalar .* = x* completed with x*
    MATRIX_VAR = 8 # matrices and varlist, matrix .* = x* completed with x*
    MATA = 9       # inline or in mata environment

# %% ../nbs/05_completions.ipynb 11
@patch_to(CompletionsManager)
def get_env(self, code, r2chars, sc_delimit_mode, mata_mode=False):
    """Returns completions environment
    Args:
        code (str): Right-truncated to cursor position
        r2chars (str): The two characters immediately after code.
            Will be used to accurately determine rcomp.
        sc_delimit_mode (bool): Whether #delimit ; is on.
        mata_mode (bool): Whether mata is on
    Returns:
        env (int):
            -2: %set magic, %set x*
            -1: magics, %x*
            0: varlist, program names, and/or file path
            1: locals, `x* completed with `x*'
            2: globals, $x* completed with $x*
            3: globals, ${x* completed with ${x*}
            4: scalars, scalar .* x* completed with x*
            5: scalars, scalar(x* completed with scalar(x*)
            6: matrices, matrix .* x* completed with x*
            7: scalars and varlist, scalar .* = x* completed with x*
            8: matrices and varlist, matrix .* = x* completed with x*
            9: mata, inline or in mata environment
        pos (int):
            Where the completions start. This is set to the start
            of the word to be completed.
        code (str):
            Word to match.
        rcomp (str):
            How to finish the completion. Blank by default.
                locals: '
                globals (if start with ${): }
                scalars: )
                scalars (if start with `): )'
    """

    lcode = code.lstrip()
#     if self.magic_completion(lcode):
#         pos = code.rfind("%") + 1
#         env = -1
#         rcomp = ""
#         return env, pos, code[pos:], rcomp
#     elif self.set_magic_completion(lcode):
#         pos = max(code.rfind(' '), code.rfind('"')) + 1
#         env = -2
#         rcomp = ""
#         return env, pos, code[pos:], rcomp

    # Detect space-delimited word.
    env = Env.GENERAL
    search = re.search(r'(?<![`$"{/])\b\w+\Z', code, flags=re.MULTILINE)
    searchpos = -1 if search is None else search.start() - 1
    pos = max(code.rfind(' '), code.rfind('"'), searchpos)
    rcomp = ''
    if pos >= 0:
        pos += 1

        if mata_mode:
            env = Env.MATA
        else:
            # Figure out if current statement is a matrix or scalar
            # statement. If so, will add them to completions list.
            if sc_delimit_mode:
                linecontext = self.context['delimit_line'](code)
            else:
                linecontext = self.context['line'](code)

            if linecontext:
                context = linecontext.groupdict()['context']
                equals = (code.find('=') > 0)
                if re.match(r'^sca(lar|la|l)?$', context.strip()):
                    env = Env.SCALAR_VAR if equals else Env.SCALAR
                elif re.match(r'^mat(rix|ri|r)?$', context.strip()):
                    env = Env.MATRIX_VAR if equals else Env.MATRIX
#                 elif self.matainline(context.strip()):
#                     env = 9

            # Constructs of the form scalar(x<tab> will be filled only
            # with scalars. This can be preceded by = or `=
            if env is Env.GENERAL:
                lfuncontext = self.context['lfunction'](code)
                if lfuncontext:
                    lfunction = lfuncontext.groupdict()['context']
                    fluff = lfuncontext.groupdict()['fluff']
                    lfluff = 0 if not fluff else len(fluff)
                    if lfunction == 'scalar':
                        env = Env.SCALAR_R
                        pos += len(lfunction) + 3 + lfluff
                        if r2chars == ")'":
                            rcomp = ""
                        elif r2chars[0:1] == ")":
                            rcomp = ""
                        elif r2chars[0:1] == "'":
                            rcomp = ")"
                        else:
                            rcomp = ")'"
                else:
                    funcontext = self.context['function'](code)
                    if funcontext:
                        function = funcontext.groupdict()['context']
                        extra = 2 if funcontext.groupdict()['equals'] else 1
                        if function == 'scalar':
                            env = Env.SCALAR_R
                            pos += len(function) + extra
                            rcomp = "" if r2chars[0:1] == ")" else ")"
    else:
        pos = 0
        if mata_mode:
            env = Env.MATA

    # Figure out if this is a local or global; env = 0 (default)
    # will suggest variables in memory.
    chunk = code[pos:]
    lfind = chunk.rfind('`')
    gfind = chunk.rfind('$')
    path_chars = any(x in chunk for x in ['/', '\\', '~'])
    chunk_quoted = chunk[lfind:].startswith('`"')

    if lfind >= 0 and (lfind > gfind) and not chunk_quoted:
        pos += lfind + 1
        env = Env.LOCAL
        rcomp = "" if r2chars[0:1] == "'" else "'"
    elif gfind >= 0 and not path_chars:
        bfind = chunk.rfind('{')
        if bfind >= 0 and (bfind > gfind):
            pos += bfind + 1
            env = Env.GLOBAL_R
            rcomp = "" if r2chars[0:1] == "}" else "}"
        else:
            env = Env.GLOBAL
            pos += gfind + 1
    elif chunk.startswith('"'):
        pos += 1
    elif chunk.startswith('`"'):
        pos += 2
    else:
        # Set to matrix or scalar environment, if applicable. Note
        # that matrices and scalars can be set to variable values,
        # so varlist is still a valid completion in a matrix or
        # scalar context.
        pass

#     if env == 9:
#         matacontext = self.matacontext(code)
#         if matacontext:
#             st, context, quote, pre = matacontext.groupdict().values()
#             varlist = [
#                 'data', 'sdata', 'store', 'sstore', 'view', 'sview',
#                 'varindex', 'varrename', 'vartype', 'isnumvar', 'isstrvar',
#                 'vartype', 'varformat', 'varlabel', 'varvaluelabel',
#                 'dropvar', 'keepvar']
#             _globals = ['global', 'global_hcat']
#             _locals = ['local']
#             scalars = ['numscalar', 'strscalar', 'numscalar_hcat']
#             matrices = [
#                 'matrix', 'matrix_hcat', 'matrixrowstripe',
#                 'matrixcolstripe', 'replacematrix']

#             posextra = 0
#             # if st:
#             #     posextra += len(st)
#             # if context:
#             #     posextra += len(context)
#             # if quote:
#             #     posextra += len(quote) + 1

#             if context in varlist:
#                 env = 0
#             elif context in _globals:
#                 env = 2
#                 rcomp = ''
#             elif context in _locals:
#                 env = 1
#                 rcomp = ''
#             elif context in scalars:
#                 env = 4
#                 rcomp = ''
#             elif context in matrices:
#                 env = 6
#                 rcomp = ''
#             else:
#                 posextra = 0

#             pos += posextra

    closing_symbol = True #config.get('autocomplete_closing_symbol', 'False')
#     closing_symbol = closing_symbol.lower() == 'true'
    if not closing_symbol:
        rcomp = ''

    return env, pos, code[pos:], rcomp

# %% ../nbs/05_completions.ipynb 12
relevant_suggestion_keys = {
    Env.GENERAL: ['varlist'],
    Env.LOCAL: ['locals'],
    Env.GLOBAL: ['globals'],
    Env.GLOBAL_R: ['globals'],
    Env.SCALAR: ['scalars'],
    Env.SCALAR_R: ['scalars'],
    Env.MATRIX: ['matrices'],
    Env.SCALAR_VAR: ['scalars', 'varlist'],
    Env.MATRIX_VAR: ['matrices', 'varlist'],
}

@patch_to(CompletionsManager)
def get(self, starts, env, rcomp):
    """Return environment-aware completions list."""
    relevant_suggestions = [var + rcomp 
                            for key in relevant_suggestion_keys[env]
                            for var in self.stata_session.suggestions[key]
                            if var.startswith(starts)]
    if env is Env.GENERAL:
        relevant_suggestions += self.get_file_paths(starts)
    return relevant_suggestions

#     elif env == 9:
#         if len(starts) > 1:
#             builtins = [
#                 var for var in mata_builtins if var.startswith(starts)]
#         else:
#             builtins = []

#         if re.search(r'[/\\]', starts):
#             paths = self.get_file_paths(starts)
#         else:
#             paths = []

#         return [
#             var for var in self.stata_session.suggestions['mata']
#             if var.startswith(starts)] + builtins + paths

# %% ../nbs/05_completions.ipynb 13
@patch_to(CompletionsManager)
def do(self, code, cursor_pos, sc_delimit_mode=False):
    env, pos, chunk, rcomp = self.get_env(
        code[:cursor_pos], 
        code[cursor_pos:(cursor_pos + 2)],
        sc_delimit_mode,
    )
    return pos, cursor_pos, self.get(chunk, env, rcomp)
